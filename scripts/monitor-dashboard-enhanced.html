<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCode Agent Monitoring Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
    <style>
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --success-color: #4CAF50;
            --error-color: #f44336;
            --warning-color: #FFC107;
            --info-color: #2196F3;
            --dark-bg: #1a1a1a;
            --dark-card: #2d2d2d;
            --dark-text: #e0e0e0;
            --light-bg: #f5f7fa;
            --light-card: #ffffff;
            --light-text: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            transition: all 0.3s ease;
            min-height: 100vh;
        }

        /* Light Theme */
        body.light {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: var(--light-text);
        }

        /* Dark Theme */
        body.dark {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: var(--dark-text);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        .header h1 {
            color: white;
            font-size: 2.5rem;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            margin-bottom: 10px;
        }

        .header-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .theme-toggle, .refresh-btn, .export-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .theme-toggle:hover, .refresh-btn:hover, .export-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.1);
            padding: 8px 16px;
            border-radius: 20px;
            color: white;
            font-size: 14px;
        }

        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .connection-dot.connected { background: var(--success-color); }
        .connection-dot.disconnected { background: var(--error-color); }
        .connection-dot.connecting { background: var(--warning-color); }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        body.light .card {
            background: rgba(255,255,255,0.9);
            color: var(--light-text);
        }

        body.dark .card {
            background: rgba(45,45,45,0.9);
            color: var(--dark-text);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            background: transparent;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .action-btn:hover {
            background: var(--primary-color);
            color: white;
        }

        .agent-card {
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .agent-card:hover {
            transform: scale(1.02);
        }

        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .agent-id {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .agent-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-running { background: rgba(76,175,80,0.2); color: var(--success-color); }
        .status-completed { background: rgba(33,150,243,0.2); color: var(--info-color); }
        .status-error { background: rgba(244,67,54,0.2); color: var(--error-color); }
        .status-pending { background: rgba(255,193,7,0.2); color: var(--warning-color); }
        .status-blocked { background: rgba(156,39,176,0.2); color: #9c27b0; }

        .agent-task {
            margin: 12px 0;
            font-size: 14px;
            opacity: 0.8;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 12px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        .progress-text {
            font-size: 12px;
            text-align: center;
            margin-top: 4px;
            opacity: 0.7;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric-label {
            font-size: 14px;
            opacity: 0.8;
        }

        .metric-value {
            font-weight: 600;
            font-size: 16px;
            color: var(--primary-color);
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        .logs-container {
            max-height: 400px;
            overflow-y: auto;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
            padding: 16px;
        }

        .log-entry {
            padding: 8px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: var(--primary-color);
            margin-right: 12px;
        }

        .log-level-error { color: var(--error-color); }
        .log-level-warn { color: var(--warning-color); }
        .log-level-info { color: var(--info-color); }
        .log-level-debug { opacity: 0.7; }

        .filters {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
        }

        .filter-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-summary {
            font-size: 14px;
            opacity: 0.8;
            padding: 8px 0;
            border-top: 1px solid rgba(0,0,0,0.1);
        }

        .filter-summary span {
            font-weight: 600;
            color: var(--primary-color);
        }

        .filter-input, .filter-select {
            padding: 8px 12px;
            border: 1px solid rgba(0,0,0,0.2);
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: inherit;
            font-size: 14px;
            min-width: 120px;
        }

        .filter-input[type="date"] {
            min-width: 140px;
        }

        .filter-input::placeholder {
            color: rgba(0,0,0,0.5);
        }

        .timeline {
            position: relative;
            padding-left: 30px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 15px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--primary-color);
        }

        .timeline-item {
            position: relative;
            margin-bottom: 24px;
            padding-left: 20px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -27px;
            top: 6px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary-color);
        }

        .timeline-time {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 4px;
        }

        .timeline-content {
            font-size: 14px;
        }

        .activity-heatmap {
            display: grid;
            grid-template-columns: repeat(24, 1fr);
            gap: 2px;
            margin-top: 16px;
        }

        .heatmap-cell {
            aspect-ratio: 1;
            border-radius: 2px;
            background: rgba(0,0,0,0.1);
            position: relative;
            cursor: pointer;
        }

        .heatmap-cell.active-1 { background: rgba(102,126,234,0.3); }
        .heatmap-cell.active-2 { background: rgba(102,126,234,0.5); }
        .heatmap-cell.active-3 { background: rgba(102,126,234,0.7); }
        .heatmap-cell.active-4 { background: rgba(102,126,234,0.9); }
        .heatmap-cell.active-5 { background: rgba(102,126,234,1); }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--light-card);
            border-radius: 12px;
            padding: 24px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            margin: 20px;
        }

        body.dark .modal-content {
            background: var(--dark-card);
            color: var(--dark-text);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
        }

        .modal-close:hover {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .dashboard-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .card {
                padding: 16px;
            }

            .header-controls {
                gap: 10px;
            }

            .filters {
                flex-direction: column;
            }
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            opacity: 0.7;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(102,126,234,0.3);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(244,67,54,0.1);
            color: var(--error-color);
            padding: 12px;
            border-radius: 6px;
            margin: 12px 0;
            border-left: 4px solid var(--error-color);
        }

        .success-message {
            background: rgba(76,175,80,0.1);
            color: var(--success-color);
            padding: 12px;
            border-radius: 6px;
            margin: 12px 0;
            border-left: 4px solid var(--success-color);
        }

        /* Offline indicator styles */
        .offline-indicator {
            background: rgba(255, 193, 7, 0.2);
            color: var(--warning-color);
            padding: 12px 20px;
            border-radius: 6px;
            margin: 12px 0;
            border-left: 4px solid var(--warning-color);
            font-weight: 600;
            text-align: center;
            animation: pulse 2s infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* Network status indicators */
        .network-status {
            display: inline-block;
            margin-left: 10px;
            font-size: 12px;
        }

        .network-status.online {
            color: var(--success-color);
        }

        .network-status.offline {
            color: var(--error-color);
        }

        /* Status notifications */
        .status-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            opacity: 1;
            transition: opacity 0.3s ease;
            max-width: 400px;
            font-size: 14px;
        }

        .status-notification.success {
            background: rgba(76, 175, 80, 0.9);
            color: white;
            border-left: 4px solid #4CAF50;
        }

        .status-notification.error {
            background: rgba(244, 67, 54, 0.9);
            color: white;
            border-left: 4px solid #f44336;
        }

        .status-notification.warning {
            background: rgba(255, 193, 7, 0.9);
            color: #333;
            border-left: 4px solid #FFC107;
        }

        .status-notification.info {
            background: rgba(33, 150, 243, 0.9);
            color: white;
            border-left: 4px solid #2196F3;
        }

        /* Enhanced connection status */
        .connection-dot {
            position: relative;
        }

        .connection-dot.connected {
            animation: pulse-success 2s infinite;
        }

        .connection-dot.connecting {
            animation: pulse-warning 1s infinite;
        }

        .connection-dot.error, .connection-dot.disconnected {
            animation: pulse-error 1s infinite;
        }

        .connection-dot.offline {
            animation: pulse-offline 2s infinite;
        }

        @keyframes pulse-success {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }

        @keyframes pulse-warning {
            0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(255, 193, 7, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
        }

        @keyframes pulse-error {
            0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(244, 67, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
        }

        @keyframes pulse-offline {
            0% { box-shadow: 0 0 0 0 rgba(156, 39, 176, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(156, 39, 176, 0); }
            100% { box-shadow: 0 0 0 0 rgba(156, 39, 176, 0); }
        }
    </style>
</head>
<body class="light">
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>ü§ñ OpenCode Agent Dashboard</h1>
            <div class="header-controls">
                <div class="status-indicator">
                    <div class="connection-dot disconnected" id="connectionStatus"></div>
                    <span id="connectionText">Disconnected</span>
                </div>
                <div class="status-indicator" id="connectionMetrics" style="display: none;">
                    <span id="metricsText">Metrics</span>
                </div>
                <button class="theme-toggle" onclick="toggleTheme()">üåì Toggle Theme</button>
                <button class="refresh-btn" onclick="refreshData()">üîÑ Refresh</button>
                <button class="export-btn" onclick="exportLogs()">üì• Export Logs</button>
            </div>
        </div>

        <!-- Main Dashboard -->
        <div class="dashboard-grid">
            <!-- Agent Status Overview -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìä Agent Status Overview</h2>
                </div>
                <div id="agentStatusOverview">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

            <!-- Task Queue -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìã Task Queue</h2>
                    <div class="card-actions">
                        <button class="action-btn" onclick="showTaskDetails()">Details</button>
                    </div>
                </div>
                <div id="taskQueue">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

            <!-- System Resources -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üíª System Resources</h2>
                </div>
                <div id="systemResources">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
                <div class="chart-container">
                    <canvas id="resourceChart"></canvas>
                </div>
            </div>

            <!-- Task Distribution -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìà Task Distribution</h2>
                </div>
                <div class="chart-container">
                    <canvas id="taskDistributionChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Active Agents Grid -->
        <div class="card" style="margin-bottom: 30px;">
            <div class="card-header">
                <h2 class="card-title">ü§ñ Active Agents</h2>
                <div class="filters">
                    <div class="filter-row">
                        <select class="filter-select" id="statusFilter" onchange="filterAgents()">
                            <option value="">All Status</option>
                            <option value="running">Running</option>
                            <option value="completed">Completed</option>
                            <option value="error">Error</option>
                            <option value="pending">Pending</option>
                            <option value="blocked">Blocked</option>
                        </select>
                        <select class="filter-select" id="typeFilter" onchange="filterAgents()">
                            <option value="">All Types</option>
                            <option value="security">Security</option>
                            <option value="testing">Testing</option>
                            <option value="performance">Performance</option>
                            <option value="documentation">Documentation</option>
                            <option value="refactoring">Refactoring</option>
                        </select>
                        <select class="filter-select" id="priorityFilter" onchange="filterAgents()">
                            <option value="">All Priorities</option>
                            <option value="high">High</option>
                            <option value="medium">Medium</option>
                            <option value="low">Low</option>
                        </select>
                        <select class="filter-select" id="sortFilter" onchange="filterAgents()">
                            <option value="newest">Newest First</option>
                            <option value="oldest">Oldest First</option>
                            <option value="priority-high">Priority (High‚ÜíLow)</option>
                            <option value="priority-low">Priority (Low‚ÜíHigh)</option>
                            <option value="status">Status</option>
                            <option value="progress">Progress</option>
                        </select>
                    </div>
                    <div class="filter-row">
                        <input type="text" class="filter-input" id="searchFilter" placeholder="Search by ID, task, or error message..." onkeyup="filterAgents()">
                        <input type="date" class="filter-input" id="dateFromFilter" onchange="filterAgents()" title="Filter from date">
                        <input type="date" class="filter-input" id="dateToFilter" onchange="filterAgents()" title="Filter to date">
                        <button class="action-btn" onclick="clearAllFilters()" title="Clear all filters">Clear</button>
                        <button class="action-btn" onclick="exportFilteredAgents()" title="Export filtered results">Export</button>
                    </div>
                    <div class="filter-summary" id="filterSummary">
                        Showing <span id="filterCount">0</span> of <span id="totalCount">0</span> agents
                    </div>
                </div>
            </div>
            <div id="activeAgents" class="dashboard-grid">
                <div class="loading"><div class="spinner"></div></div>
            </div>
        </div>

        <!-- Timeline and Logs -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
            <!-- Timeline -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">‚è±Ô∏è Timeline</h2>
                </div>
                <div id="timeline" class="timeline">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

            <!-- Activity Heatmap -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üî• Activity Heatmap (24h)</h2>
                </div>
                <div id="activityHeatmap" class="activity-heatmap">
                    <!-- Generated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Logs Viewer -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">üìú Live Logs</h2>
                <div class="card-actions">
                    <button class="action-btn" onclick="clearLogs()">Clear</button>
                    <button class="action-btn" onclick="toggleLogAutoScroll()">Auto-scroll: ON</button>
                </div>
            </div>
            <div class="filters">
                <select class="filter-select" id="logLevelFilter" onchange="filterLogs()">
                    <option value="">All Levels</option>
                    <option value="error">Error</option>
                    <option value="warn">Warning</option>
                    <option value="info">Info</option>
                    <option value="debug">Debug</option>
                </select>
                <input type="text" class="filter-input" id="logSearchFilter" placeholder="Search logs..." onkeyup="filterLogs()">
            </div>
            <div id="logsContainer" class="logs-container">
                <div class="loading"><div class="spinner"></div></div>
            </div>
        </div>
    </div>

    <!-- Modal for detailed views -->
    <div class="modal" id="detailModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Details</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div id="modalBody">
                <!-- Dynamic content -->
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let websocket = null;
        let reconnectInterval = null;
        let heartbeatInterval = null;
        let agents = [];
        let tasks = [];
        let logs = [];
        let resourceData = [];
        let currentTheme = 'light';
        let autoScrollLogs = true;
        let charts = {};
        
        // WebSocket connection management
        let connectionState = 'disconnected'; // disconnected, connecting, connected, error
        let connectionAttempts = 0;
        let maxReconnectAttempts = 10;
        let baseReconnectDelay = 1000; // 1 second
        let maxReconnectDelay = 30000; // 30 seconds
        let heartbeatInterval_ms = 30000; // 30 seconds
        let connectionMetrics = {
            connectTime: null,
            lastHeartbeat: null,
            messagesSent: 0,
            messagesReceived: 0,
            reconnectCount: 0,
            totalDowntime: 0
        };
        
        // Network connectivity detection
        let networkState = {
            isOnline: navigator.onLine || true,
            lastCheck: new Date(),
            checkInterval: null,
            pingInterval: 5000, // 5 seconds
            serverReachable: false
        };

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            initializeCharts();
            initializeNetworkDetection();
            addDiagnosticStyles();
            addDiagnosticButton();
            initializeWebSocket();
            loadDemoData();
            generateActivityHeatmap();
            setInterval(updateResourceChart, 5000);
            setInterval(refreshData, 10000); // Auto-refresh every 10 seconds
        });

        // Enhanced WebSocket connection with validation and health monitoring
        function initializeWebSocket() {
            if (connectionState === 'connecting') return; // Prevent multiple connection attempts
            
            connectionState = 'connecting';
            updateConnectionStatus('connecting', 'Connecting...');
            
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//localhost:8080/ws`;

            try {
                websocket = new WebSocket(wsUrl);
                
                // Set connection timeout
                const connectionTimeout = setTimeout(() => {
                    if (connectionState === 'connecting') {
                        websocket.close();
                        handleConnectionFailure('Connection timeout');
                    }
                }, 10000); // 10 second timeout

                websocket.onopen = function() {
                    clearTimeout(connectionTimeout);
                    connectionState = 'connected';
                    connectionAttempts = 0;
                    connectionMetrics.connectTime = new Date();
                    connectionMetrics.reconnectCount = connectionAttempts > 0 ? connectionMetrics.reconnectCount + 1 : 0;
                    
                    updateConnectionStatus('connected', 'Connected');
                    console.log('WebSocket connected successfully');
                    
                    // Start heartbeat mechanism
                    startHeartbeat();
                    
                    // Request initial data when connected
                    sendMessage({ type: 'request_status' });
                    
                    addLogEntry({
                        time: new Date(),
                        level: 'info',
                        message: 'WebSocket connection established',
                        agent: 'dashboard'
                    });
                };

                websocket.onmessage = function(event) {
                    connectionMetrics.messagesReceived++;
                    connectionMetrics.lastHeartbeat = new Date();
                    
                    try {
                        const data = JSON.parse(event.data);
                        
                        // Handle heartbeat response
                        if (data.type === 'pong') {
                            return; // Just update metrics, no further processing needed
                        }
                        
                        handleWebSocketMessage(data);
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                        addLogEntry({
                            time: new Date(),
                            level: 'error',
                            message: `WebSocket message parse error: ${error.message}`,
                            agent: 'dashboard'
                        });
                    }
                };

                websocket.onclose = function(event) {
                    clearTimeout(connectionTimeout);
                    stopHeartbeat();
                    
                    const wasConnected = connectionState === 'connected';
                    connectionState = 'disconnected';
                    
                    console.log('WebSocket disconnected', event.code, event.reason);
                    
                    if (event.code === 1000) {
                        // Normal closure
                        updateConnectionStatus('disconnected', 'Disconnected');
                        addLogEntry({
                            time: new Date(),
                            level: 'info',
                            message: 'WebSocket connection closed normally',
                            agent: 'dashboard'
                        });
                    } else if (event.code === 1006 || event.code === 1001) {
                        // Abnormal closure or going away - attempt reconnection
                        handleConnectionFailure(`Connection lost (${event.code})`);
                    } else {
                        // Other closure codes
                        handleConnectionFailure(`Connection closed with code ${event.code}: ${event.reason || 'Unknown'}`);
                    }
                };

                websocket.onerror = function(error) {
                    clearTimeout(connectionTimeout);
                    console.error('WebSocket error:', error);
                    handleConnectionFailure('WebSocket error occurred');
                };

            } catch (error) {
                console.error('Failed to create WebSocket connection:', error);
                handleConnectionFailure(`Failed to initialize WebSocket: ${error.message}`);
            }
        }
        
        // Enhanced connection failure handling with exponential backoff
        function handleConnectionFailure(reason) {
            connectionState = 'error';
            updateConnectionStatus('disconnected', `Error: ${reason}`);
            
            addLogEntry({
                time: new Date(),
                level: 'error',
                message: reason,
                agent: 'dashboard'
            });
            
            // Stop any existing reconnection attempts
            if (reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }
            
            // Attempt reconnection with exponential backoff
            if (connectionAttempts < maxReconnectAttempts) {
                connectionAttempts++;
                const delay = Math.min(baseReconnectDelay * Math.pow(2, connectionAttempts - 1), maxReconnectDelay);
                
                updateConnectionStatus('connecting', `Reconnecting in ${Math.round(delay/1000)}s... (${connectionAttempts}/${maxReconnectAttempts})`);
                
                reconnectInterval = setTimeout(() => {
                    reconnectInterval = null;
                    initializeWebSocket();
                }, delay);
            } else {
                updateConnectionStatus('disconnected', 'Max reconnection attempts reached');
                addLogEntry({
                    time: new Date(),
                    level: 'error',
                    message: 'Maximum reconnection attempts reached. Switching to offline mode.',
                    agent: 'dashboard'
                });
                // Enhanced fallback strategy
                activateEnhancedFallbackMode();
            }
        }
        
        // Heartbeat mechanism for connection health monitoring
        function startHeartbeat() {
            stopHeartbeat(); // Clear any existing heartbeat
            
            heartbeatInterval = setInterval(() => {
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    sendMessage({ type: 'ping', timestamp: new Date().getTime() });
                    
                    // Check if we haven't received a heartbeat response in a while
                    const timeSinceLastHeartbeat = connectionMetrics.lastHeartbeat ? 
                        Date.now() - connectionMetrics.lastHeartbeat.getTime() : Infinity;
                    
                    if (timeSinceLastHeartbeat > heartbeatInterval_ms * 2) {
                        console.warn('Heartbeat timeout detected, forcing reconnection');
                        websocket.close(1006, 'Heartbeat timeout');
                    }
                } else {
                    stopHeartbeat();
                }
            }, heartbeatInterval_ms);
        }
        
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }
        
        // Network connectivity detection functions
        function initializeNetworkDetection() {
            // Listen for browser online/offline events
            window.addEventListener('online', handleNetworkOnline);
            window.addEventListener('offline', handleNetworkOffline);
            
            // Start periodic server connectivity check
            startNetworkMonitoring();
            
            // Initial network state check
            checkNetworkConnectivity();
        }
        
        function handleNetworkOnline() {
            networkState.isOnline = true;
            networkState.lastCheck = new Date();
            
            addLogEntry({
                time: new Date(),
                level: 'info',
                message: 'Network connectivity restored',
                agent: 'dashboard'
            });
            
            // Try to reconnect WebSocket if needed
            if (connectionState === 'disconnected' || connectionState === 'error') {
                connectionAttempts = 0; // Reset connection attempts
                initializeWebSocket();
            }
        }
        
        function handleNetworkOffline() {
            networkState.isOnline = false;
            networkState.serverReachable = false;
            networkState.lastCheck = new Date();
            
            addLogEntry({
                time: new Date(),
                level: 'warn',
                message: 'Network connectivity lost - switching to offline mode',
                agent: 'dashboard'
            });
            
            updateConnectionStatus('offline', 'Offline mode - cached data only');
            enableOfflineMode();
        }
        
        function startNetworkMonitoring() {
            if (networkState.checkInterval) {
                clearInterval(networkState.checkInterval);
            }
            
            networkState.checkInterval = setInterval(checkNetworkConnectivity, networkState.pingInterval);
        }
        
        function stopNetworkMonitoring() {
            if (networkState.checkInterval) {
                clearInterval(networkState.checkInterval);
                networkState.checkInterval = null;
            }
        }
        
        async function checkNetworkConnectivity() {
            if (!networkState.isOnline) {
                return false; // Browser is offline
            }
            
            try {
                // Try to reach the server with a simple HTTP request
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout
                
                const response = await fetch('/health', {
                    method: 'HEAD',
                    signal: controller.signal,
                    cache: 'no-cache'
                });
                
                clearTimeout(timeoutId);
                
                const wasReachable = networkState.serverReachable;
                networkState.serverReachable = response.ok;
                networkState.lastCheck = new Date();
                
                // If server became reachable after being unreachable
                if (networkState.serverReachable && !wasReachable) {
                    addLogEntry({
                        time: new Date(),
                        level: 'info',
                        message: 'Server connectivity restored',
                        agent: 'dashboard'
                    });
                    
                    // Attempt WebSocket reconnection if needed
                    if (connectionState !== 'connected') {
                        connectionAttempts = 0;
                        initializeWebSocket();
                    }
                }
                
                return networkState.serverReachable;
            } catch (error) {
                const wasReachable = networkState.serverReachable;
                networkState.serverReachable = false;
                networkState.lastCheck = new Date();
                
                if (wasReachable) {
                    addLogEntry({
                        time: new Date(),
                        level: 'warn',
                        message: `Server unreachable: ${error.message}`,
                        agent: 'dashboard'
                    });
                }
                
                return false;
            }
        }
        
        function enableOfflineMode() {
            // Switch to cached data or demo data
            if (!hasValidCachedData()) {
                loadDemoData();
            } else {
                loadCachedData();
            }
            
            // Update UI to show offline state
            showOfflineNotification();
        }
        
        // Enhanced fallback mode with multiple fallback strategies
        function activateEnhancedFallbackMode() {
            addLogEntry({
                time: new Date(),
                level: 'info',
                message: 'Activating enhanced fallback mode...',
                agent: 'dashboard'
            });
            
            // Strategy 1: Try to load cached data first
            if (hasValidCachedData() && loadCachedData()) {
                addLogEntry({
                    time: new Date(),
                    level: 'info',
                    message: 'Using cached data for offline operation',
                    agent: 'dashboard'
                });
                showOfflineNotification();
                return;
            }
            
            // Strategy 2: Try to load from browser storage (session storage)
            if (loadFromSessionStorage()) {
                addLogEntry({
                    time: new Date(),
                    level: 'info',
                    message: 'Using session data for offline operation',
                    agent: 'dashboard'
                });
                showOfflineNotification();
                return;
            }
            
            // Strategy 3: Generate intelligent demo data based on time of day
            loadIntelligentDemoData();
            addLogEntry({
                time: new Date(),
                level: 'info',
                message: 'Using intelligent demo data for offline operation',
                agent: 'dashboard'
            });
            showOfflineNotification();
            
            // Enable offline functionality features
            enableOfflineFeatures();
        }
        
        function loadFromSessionStorage() {
            if (!sessionStorage) return false;
            
            try {
                const sessionData = JSON.parse(sessionStorage.getItem('dashboardSession') || '{}');
                if (!sessionData.agents && !sessionData.tasks) return false;
                
                agents = Array.isArray(sessionData.agents) ? sessionData.agents : [];
                tasks = Array.isArray(sessionData.tasks) ? sessionData.tasks : [];
                logs = Array.isArray(sessionData.logs) ? sessionData.logs : [];
                
                updateAllDisplays();
                return true;
            } catch (error) {
                console.warn('Failed to load session data:', error);
                return false;
            }
        }
        
        function loadIntelligentDemoData() {
            const currentHour = new Date().getHours();
            const isWorkingHours = currentHour >= 9 && currentHour <= 17;
            const isWeekend = new Date().getDay() === 0 || new Date().getDay() === 6;
            
            // Generate demo data based on time context
            const agentCount = isWorkingHours && !isWeekend ? 6 : 3;
            const taskTypes = ['security', 'testing', 'performance', 'documentation', 'refactoring', 'deployment'];
            
            agents = [];
            tasks = [];
            
            for (let i = 0; i < agentCount; i++) {
                const type = taskTypes[i % taskTypes.length];
                const status = getRealisticStatus(currentHour, isWorkingHours);
                
                agents.push({
                    id: `${type}_${Date.now() + i}`,
                    type: type,
                    status: status,
                    task: getRealisticTask(type, currentHour),
                    progress: getRealisticProgress(status),
                    startTime: new Date(Date.now() - Math.random() * 3600000), // Within last hour
                    priority: getRealisticPriority(type),
                    ...(status === 'completed' && { endTime: new Date(Date.now() - Math.random() * 1800000) }),
                    ...(status === 'error' && { error: getRealisticError(type) })
                });
                
                tasks.push({
                    id: (i + 1).toString(),
                    type: type,
                    status: status === 'running' ? 'in_progress' : status,
                    priority: getRealisticPriority(type),
                    description: getRealisticTask(type, currentHour)
                });
            }
            
            // Generate contextual logs
            logs = generateContextualLogs(currentHour, isWorkingHours, isWeekend);
            
            updateAllDisplays();
        }
        
        function getRealisticStatus(hour, isWorkingHours) {
            const statuses = ['running', 'completed', 'pending', 'error'];
            
            if (!isWorkingHours) {
                // More completed/pending tasks outside working hours
                return Math.random() < 0.6 ? 'completed' : 'pending';
            }
            
            // During working hours, more active tasks
            const weights = [0.4, 0.3, 0.2, 0.1]; // running, completed, pending, error
            const random = Math.random();
            let sum = 0;
            
            for (let i = 0; i < weights.length; i++) {
                sum += weights[i];
                if (random < sum) return statuses[i];
            }
            
            return 'pending';
        }
        
        function getRealisticTask(type, hour) {
            const tasks = {
                security: [
                    'Performing vulnerability scan on authentication module',
                    'Analyzing code for SQL injection patterns',
                    'Updating security dependencies',
                    'Reviewing access control permissions'
                ],
                testing: [
                    'Running unit test suite',
                    'Executing integration tests',
                    'Performance testing user flows',
                    'Validating API endpoints'
                ],
                performance: [
                    'Optimizing database queries',
                    'Analyzing memory usage patterns',
                    'Compressing static assets',
                    'Implementing caching strategies'
                ],
                documentation: [
                    'Updating API documentation',
                    'Writing deployment guides',
                    'Creating user manuals',
                    'Generating code documentation'
                ],
                refactoring: [
                    'Cleaning up legacy code',
                    'Modernizing component architecture',
                    'Optimizing data structures',
                    'Removing unused dependencies'
                ],
                deployment: [
                    'Building production artifacts',
                    'Running deployment pipeline',
                    'Updating production environment',
                    'Verifying deployment status'
                ]
            };
            
            const typeTasks = tasks[type] || tasks.testing;
            return typeTasks[Math.floor(Math.random() * typeTasks.length)];
        }
        
        function getRealisticProgress(status) {
            switch (status) {
                case 'completed': return 100;
                case 'error': return Math.floor(Math.random() * 50) + 10;
                case 'running': return Math.floor(Math.random() * 80) + 10;
                case 'pending': return 0;
                default: return 0;
            }
        }
        
        function getRealisticPriority(type) {
            const priorities = {
                security: 'high',
                deployment: 'high',
                testing: 'medium',
                performance: 'medium',
                refactoring: 'low',
                documentation: 'low'
            };
            return priorities[type] || 'medium';
        }
        
        function getRealisticError(type) {
            const errors = {
                security: 'Scan timeout due to network latency',
                testing: 'Test environment unavailable',
                performance: 'Memory limit exceeded during analysis',
                documentation: 'Failed to parse code annotations',
                refactoring: 'Dependency conflict detected',
                deployment: 'Build pipeline configuration error'
            };
            return errors[type] || 'Unknown error occurred';
        }
        
        function generateContextualLogs(hour, isWorkingHours, isWeekend) {
            const contextualLogs = [];
            const baseTime = Date.now();
            
            // Generate logs based on time context
            const logCount = isWorkingHours && !isWeekend ? 8 : 4;
            
            for (let i = 0; i < logCount; i++) {
                const logTime = new Date(baseTime - (i * 15000)); // 15 seconds apart
                const level = Math.random() < 0.7 ? 'info' : Math.random() < 0.8 ? 'warn' : 'error';
                
                contextualLogs.unshift({
                    time: logTime,
                    level: level,
                    message: getContextualLogMessage(level, hour, isWorkingHours),
                    agent: getRandomAgent()
                });
            }
            
            return contextualLogs;
        }
        
        function getContextualLogMessage(level, hour, isWorkingHours) {
            const messages = {
                info: [
                    isWorkingHours ? 'Agent started successfully' : 'Scheduled maintenance completed',
                    'Task queue processed',
                    'System health check passed',
                    'Configuration updated'
                ],
                warn: [
                    'High CPU usage detected',
                    'Memory usage approaching limit',
                    'Slow database query detected',
                    'Network latency increased'
                ],
                error: [
                    'Connection timeout occurred',
                    'Authentication failure',
                    'Database connection lost',
                    'Service temporarily unavailable'
                ]
            };
            
            const levelMessages = messages[level] || messages.info;
            return levelMessages[Math.floor(Math.random() * levelMessages.length)];
        }
        
        function getRandomAgent() {
            const agents = ['security_agent', 'testing_agent', 'perf_agent', 'docs_agent', 'deploy_agent'];
            return agents[Math.floor(Math.random() * agents.length)];
        }
        
        function enableOfflineFeatures() {
            // Enable features that work offline
            addOfflineControls();
            enableDataExport();
            enableLocalSearch();
        }
        
        function addOfflineControls() {
            const header = document.querySelector('.header-controls');
            if (!header || document.getElementById('offlineControls')) return;
            
            const offlineControls = document.createElement('div');
            offlineControls.id = 'offlineControls';
            offlineControls.innerHTML = `
                <button class="refresh-btn" onclick="retryConnection()" title="Retry Connection">üîÑ Retry</button>
                <button class="refresh-btn" onclick="clearCache()" title="Clear Cache">üóëÔ∏è Clear Cache</button>
            `;
            
            header.appendChild(offlineControls);
        }
        
        function retryConnection() {
            addLogEntry({
                time: new Date(),
                level: 'info',
                message: 'Manual connection retry initiated',
                agent: 'dashboard'
            });
            
            connectionAttempts = 0;
            initializeWebSocket();
        }
        
        function enableDataExport() {
            // Already exists in the original implementation
        }
        
        function enableLocalSearch() {
            // Enhance existing search functionality for offline use
            const searchInputs = document.querySelectorAll('.filter-input');
            searchInputs.forEach(input => {
                if (!input.hasAttribute('data-offline-enabled')) {
                    input.setAttribute('data-offline-enabled', 'true');
                    input.placeholder += ' (offline mode)';
                }
            });
        }
        
        function showOfflineNotification() {
            // Add offline indicator to the UI
            const offlineIndicator = document.createElement('div');
            offlineIndicator.id = 'offlineIndicator';
            offlineIndicator.className = 'offline-indicator';
            offlineIndicator.innerHTML = '‚ö†Ô∏è Offline Mode - Data may be outdated';
            
            // Remove existing indicator if present
            const existing = document.getElementById('offlineIndicator');
            if (existing) {
                existing.remove();
            }
            
            // Insert at top of main content
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                mainContent.insertBefore(offlineIndicator, mainContent.firstChild);
            }
        }
        
        function hideOfflineNotification() {
            const indicator = document.getElementById('offlineIndicator');
            if (indicator) {
                indicator.remove();
            }
        }
        
        // Local storage caching functions
        function saveDataToCache() {
            if (!localStorage) return;
            
            try {
                const cacheData = {
                    agents: agents,
                    tasks: tasks,
                    logs: logs.slice(-100), // Keep only last 100 logs
                    resourceData: resourceData.slice(-50), // Keep only last 50 resource entries
                    timestamp: new Date().getTime(),
                    version: '1.0'
                };
                
                localStorage.setItem('dashboardCache', JSON.stringify(cacheData));
                localStorage.setItem('dashboardCacheTime', cacheData.timestamp.toString());
            } catch (error) {
                console.warn('Failed to save data to cache:', error);
                addLogEntry({
                    time: new Date(),
                    level: 'warn',
                    message: `Cache save failed: ${error.message}`,
                    agent: 'dashboard'
                });
            }
        }
        
        function loadCachedData() {
            if (!localStorage) return false;
            
            try {
                const cacheData = JSON.parse(localStorage.getItem('dashboardCache'));
                const cacheTime = parseInt(localStorage.getItem('dashboardCacheTime') || '0');
                
                if (!cacheData || !cacheTime) return false;
                
                // Check if cache is not too old (max 1 hour)
                const maxCacheAge = 60 * 60 * 1000; // 1 hour in milliseconds
                const age = Date.now() - cacheTime;
                
                if (age > maxCacheAge) {
                    console.log('Cache expired, falling back to demo data');
                    return false;
                }
                
                // Load cached data
                agents = Array.isArray(cacheData.agents) ? cacheData.agents : [];
                tasks = Array.isArray(cacheData.tasks) ? cacheData.tasks : [];
                logs = Array.isArray(cacheData.logs) ? cacheData.logs : [];
                resourceData = Array.isArray(cacheData.resourceData) ? cacheData.resourceData : [];
                
                // Add cache load log entry
                addLogEntry({
                    time: new Date(),
                    level: 'info',
                    message: `Loaded cached data from ${new Date(cacheTime).toLocaleTimeString()}`,
                    agent: 'dashboard'
                });
                
                updateAllDisplays();
                return true;
            } catch (error) {
                console.warn('Failed to load cached data:', error);
                addLogEntry({
                    time: new Date(),
                    level: 'warn',
                    message: `Cache load failed: ${error.message}`,
                    agent: 'dashboard'
                });
                return false;
            }
        }
        
        function hasValidCachedData() {
            if (!localStorage) return false;
            
            try {
                const cacheTime = parseInt(localStorage.getItem('dashboardCacheTime') || '0');
                if (!cacheTime) return false;
                
                const maxCacheAge = 60 * 60 * 1000; // 1 hour
                const age = Date.now() - cacheTime;
                
                return age <= maxCacheAge;
            } catch (error) {
                return false;
            }
        }
        
        function clearCache() {
            if (!localStorage) return;
            
            try {
                localStorage.removeItem('dashboardCache');
                localStorage.removeItem('dashboardCacheTime');
                addLogEntry({
                    time: new Date(),
                    level: 'info',
                    message: 'Dashboard cache cleared',
                    agent: 'dashboard'
                });
            } catch (error) {
                console.warn('Failed to clear cache:', error);
            }
        }
        
        // Enhanced message sending with validation
        function sendMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                try {
                    const messageStr = JSON.stringify(message);
                    websocket.send(messageStr);
                    connectionMetrics.messagesSent++;
                    return true;
                } catch (error) {
                    console.error('Error sending WebSocket message:', error);
                    addLogEntry({
                        time: new Date(),
                        level: 'error',
                        message: `Failed to send message: ${error.message}`,
                        agent: 'dashboard'
                    });
                    return false;
                }
            } else {
                console.warn('Cannot send message: WebSocket not connected');
                return false;
            }
        }

        function handleWebSocketMessage(data) {
            // Validate message structure
            if (!data || typeof data !== 'object') {
                console.warn('Invalid WebSocket message received:', data);
                return;
            }
            
            switch (data.type) {
                case 'agent_update':
                    if (data.agent && data.agent.id) {
                        updateAgent(data.agent);
                        logAgentStatusChange(data.agent);
                    }
                    break;
                case 'task_update':
                    if (data.task && data.task.id) {
                        updateTask(data.task);
                    }
                    break;
                case 'log_entry':
                    if (data.log) {
                        addLogEntry(data.log);
                    }
                    break;
                case 'resource_update':
                    if (data.resources) {
                        updateResourceData(data.resources);
                    }
                    break;
                case 'full_status':
                    agents = Array.isArray(data.agents) ? data.agents : [];
                    tasks = Array.isArray(data.tasks) ? data.tasks : [];
                    updateAllDisplays();
                    addLogEntry({
                        time: new Date(),
                        level: 'info',
                        message: `Status update received: ${agents.length} agents, ${tasks.length} tasks`,
                        agent: 'dashboard'
                    });
                    break;
                case 'agent_metrics':
                    if (data.metrics) {
                        updateAgentMetrics(data.metrics);
                    }
                    break;
                case 'system_alert':
                    if (data.alert) {
                        handleSystemAlert(data.alert);
                    }
                    break;
                default:
                    console.log('Unknown message type received:', data.type);
            }
            
            // Cache data after processing updates (throttled to avoid excessive writes)
            if (!handleWebSocketMessage.cacheTimer) {
                handleWebSocketMessage.cacheTimer = setTimeout(() => {
                    saveDataToCache();
                    handleWebSocketMessage.cacheTimer = null;
                }, 5000); // Cache at most once every 5 seconds
            }
        }
        
        // Log significant agent status changes
        function logAgentStatusChange(agent) {
            const existingAgent = agents.find(a => a.id === agent.id);
            if (existingAgent && existingAgent.status !== agent.status) {
                addLogEntry({
                    time: new Date(),
                    level: agent.status === 'error' ? 'error' : 'info',
                    message: `Agent ${agent.id} status changed from ${existingAgent.status} to ${agent.status}`,
                    agent: agent.id
                });
            }
        }
        
        // Handle system alerts
        function handleSystemAlert(alert) {
            addLogEntry({
                time: new Date(),
                level: alert.severity || 'warn',
                message: alert.message || 'System alert received',
                agent: 'system'
            });
            
            // Show visual notification for critical alerts
            if (alert.severity === 'error' || alert.severity === 'critical') {
                showNotification(alert.message, 'error');
            }
        }
        
        // Update agent metrics
        function updateAgentMetrics(metrics) {
            // Update performance metrics display
            if (metrics.performance) {
                updatePerformanceMetrics(metrics.performance);
            }
            
            // Update resource usage
            if (metrics.resources) {
                updateResourceData(metrics.resources);
            }
        }
        
        // Enhanced connection status with additional metrics and user feedback
        function updateConnectionStatus(status, text) {
            const dot = document.getElementById('connectionStatus');
            const textEl = document.getElementById('connectionText');

            if (dot) dot.className = `connection-dot ${status}`;
            if (textEl) {
                let displayText = text;
                
                // Add connection metrics for connected state
                if (status === 'connected' && connectionMetrics.connectTime) {
                    const uptime = Math.floor((Date.now() - connectionMetrics.connectTime.getTime()) / 1000);
                    displayText += ` (${uptime}s uptime)`;
                    
                    // Show success notification on reconnection
                    if (connectionAttempts > 0) {
                        showStatusNotification('Connection restored successfully!', 'success', 3000);
                        hideOfflineNotification();
                    }
                }
                
                // Add network status indicator
                const networkIndicator = getNetworkStatusIndicator();
                displayText += networkIndicator;
                
                textEl.textContent = displayText;
            }

            // Clear reconnection interval if successfully connected
            if (status === 'connected' && reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }
            
            // Show status-specific notifications
            showStatusSpecificFeedback(status, text);
            
            // Update connection metrics display
            updateConnectionMetricsDisplay();
        }
        
        function getNetworkStatusIndicator() {
            if (!networkState.isOnline) {
                return ' üî¥ Offline';
            } else if (!networkState.serverReachable) {
                return ' üü° Server unreachable';
            } else {
                return ' üü¢ Online';
            }
        }
        
        function showStatusSpecificFeedback(status, text) {
            switch (status) {
                case 'connecting':
                    if (connectionAttempts > 1) {
                        showStatusNotification(`Reconnection attempt ${connectionAttempts}/${maxReconnectAttempts}`, 'info', 2000);
                    }
                    break;
                    
                case 'error':
                case 'disconnected':
                    if (connectionAttempts >= maxReconnectAttempts) {
                        showStatusNotification('Connection failed - switched to offline mode', 'error', 5000);
                    } else if (connectionAttempts > 0) {
                        showStatusNotification('Connection lost - retrying...', 'warning', 3000);
                    }
                    break;
                    
                case 'offline':
                    showStatusNotification('Offline mode activated - using cached data', 'warning', 4000);
                    break;
            }
        }
        
        function showStatusNotification(message, type = 'info', duration = 3000) {
            // Remove existing notification
            const existing = document.getElementById('statusNotification');
            if (existing) {
                existing.remove();
            }
            
            // Create new notification
            const notification = document.createElement('div');
            notification.id = 'statusNotification';
            notification.className = `status-notification ${type}`;
            
            const icon = getNotificationIcon(type);
            notification.innerHTML = `${icon} ${message}`;
            
            // Position and show notification
            document.body.appendChild(notification);
            
            // Auto-hide after duration
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, duration);
        }
        
        function getNotificationIcon(type) {
            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };
            return icons[type] || icons.info;
        }
        
        // Enhanced connection diagnostics
        function showConnectionDiagnostics() {
            const diagnostics = {
                browserOnline: navigator.onLine,
                serverReachable: networkState.serverReachable,
                websocketState: connectionState,
                connectionAttempts: connectionAttempts,
                lastCheck: networkState.lastCheck,
                uptime: connectionMetrics.connectTime ? Math.floor((Date.now() - connectionMetrics.connectTime.getTime()) / 1000) : 0,
                messagesSent: connectionMetrics.messagesSent,
                messagesReceived: connectionMetrics.messagesReceived,
                lastHeartbeat: connectionMetrics.lastHeartbeat,
                cacheAvailable: hasValidCachedData()
            };
            
            const modal = document.getElementById('detailModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');
            
            title.textContent = 'Connection Diagnostics';
            body.innerHTML = `
                <div class="diagnostics-grid">
                    <div class="diagnostic-item">
                        <strong>Browser Status:</strong>
                        <span class="status-badge ${diagnostics.browserOnline ? 'success' : 'error'}">
                            ${diagnostics.browserOnline ? 'üü¢ Online' : 'üî¥ Offline'}
                        </span>
                    </div>
                    <div class="diagnostic-item">
                        <strong>Server Reachable:</strong>
                        <span class="status-badge ${diagnostics.serverReachable ? 'success' : 'error'}">
                            ${diagnostics.serverReachable ? 'üü¢ Yes' : 'üî¥ No'}
                        </span>
                    </div>
                    <div class="diagnostic-item">
                        <strong>WebSocket State:</strong>
                        <span class="status-badge ${diagnostics.websocketState === 'connected' ? 'success' : 'warning'}">
                            ${diagnostics.websocketState}
                        </span>
                    </div>
                    <div class="diagnostic-item">
                        <strong>Connection Attempts:</strong>
                        <span>${diagnostics.connectionAttempts}/${maxReconnectAttempts}</span>
                    </div>
                    <div class="diagnostic-item">
                        <strong>Last Network Check:</strong>
                        <span>${diagnostics.lastCheck ? diagnostics.lastCheck.toLocaleTimeString() : 'Never'}</span>
                    </div>
                    <div class="diagnostic-item">
                        <strong>Connection Uptime:</strong>
                        <span>${diagnostics.uptime > 0 ? diagnostics.uptime + 's' : 'Not connected'}</span>
                    </div>
                    <div class="diagnostic-item">
                        <strong>Messages Sent:</strong>
                        <span>${diagnostics.messagesSent}</span>
                    </div>
                    <div class="diagnostic-item">
                        <strong>Messages Received:</strong>
                        <span>${diagnostics.messagesReceived}</span>
                    </div>
                    <div class="diagnostic-item">
                        <strong>Last Heartbeat:</strong>
                        <span>${diagnostics.lastHeartbeat ? diagnostics.lastHeartbeat.toLocaleTimeString() : 'Never'}</span>
                    </div>
                    <div class="diagnostic-item">
                        <strong>Cache Available:</strong>
                        <span class="status-badge ${diagnostics.cacheAvailable ? 'success' : 'warning'}">
                            ${diagnostics.cacheAvailable ? 'üü¢ Yes' : 'üü° No/Expired'}
                        </span>
                    </div>
                </div>
                
                <div class="diagnostic-actions">
                    <button class="refresh-btn" onclick="retryConnection()">üîÑ Retry Connection</button>
                    <button class="refresh-btn" onclick="clearCache()">üóëÔ∏è Clear Cache</button>
                    <button class="refresh-btn" onclick="checkNetworkConnectivity()">üì° Test Network</button>
                </div>
            `;
            
            modal.style.display = 'flex';
        }
        
        // Add diagnostic styles
        function addDiagnosticStyles() {
            const style = document.createElement('style');
            style.textContent = `
                .diagnostics-grid {
                    display: grid;
                    gap: 12px;
                    margin-bottom: 20px;
                }
                
                .diagnostic-item {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 8px;
                    background: var(--card-background);
                    border-radius: 6px;
                    border: 1px solid var(--border-color);
                }
                
                .diagnostic-actions {
                    display: flex;
                    gap: 10px;
                    justify-content: center;
                    flex-wrap: wrap;
                }
                
                .status-badge {
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    font-weight: 600;
                }
                
                .status-badge.success {
                    background: rgba(76, 175, 80, 0.2);
                    color: var(--success-color);
                }
                
                .status-badge.warning {
                    background: rgba(255, 193, 7, 0.2);
                    color: var(--warning-color);
                }
                
                .status-badge.error {
                    background: rgba(244, 67, 54, 0.2);
                    color: var(--error-color);
                }
            `;
            
            if (!document.querySelector('style[data-diagnostic-styles]')) {
                style.setAttribute('data-diagnostic-styles', 'true');
                document.head.appendChild(style);
            }
        }
        
        // Add diagnostic button to header
        function addDiagnosticButton() {
            const headerControls = document.querySelector('.header-controls');
            if (!headerControls || document.getElementById('diagnosticsBtn')) return;
            
            const diagnosticsBtn = document.createElement('button');
            diagnosticsBtn.id = 'diagnosticsBtn';
            diagnosticsBtn.className = 'refresh-btn';
            diagnosticsBtn.innerHTML = 'üîç Diagnostics';
            diagnosticsBtn.onclick = showConnectionDiagnostics;
            diagnosticsBtn.title = 'Show connection diagnostics';
            
            headerControls.appendChild(diagnosticsBtn);
        }

        // Demo data for fallback
        function loadDemoData() {
            agents = [
                {
                    id: 'security_' + Date.now(),
                    type: 'security',
                    status: 'running',
                    task: 'Performing security audit on authentication module',
                    progress: 65,
                    startTime: new Date(Date.now() - 300000),
                    priority: 'high'
                },
                {
                    id: 'testing_' + (Date.now() + 1),
                    type: 'testing',
                    status: 'completed',
                    task: 'Added unit tests for user service',
                    progress: 100,
                    startTime: new Date(Date.now() - 600000),
                    endTime: new Date(Date.now() - 60000),
                    priority: 'medium'
                },
                {
                    id: 'perf_' + (Date.now() + 2),
                    type: 'performance',
                    status: 'pending',
                    task: 'Database query optimization',
                    progress: 0,
                    priority: 'high'
                },
                {
                    id: 'docs_' + (Date.now() + 3),
                    type: 'documentation',
                    status: 'error',
                    task: 'API documentation generation',
                    progress: 25,
                    startTime: new Date(Date.now() - 180000),
                    error: 'Failed to parse OpenAPI specification',
                    priority: 'low'
                }
            ];

            tasks = [
                { id: '1', type: 'security', status: 'in_progress', priority: 'high', description: 'Security audit' },
                { id: '2', type: 'testing', status: 'completed', priority: 'medium', description: 'Unit tests' },
                { id: '3', type: 'performance', status: 'pending', priority: 'high', description: 'Performance optimization' },
                { id: '4', type: 'documentation', status: 'blocked', priority: 'low', description: 'Documentation update' }
            ];

            // Generate demo logs
            logs = [
                { time: new Date(), level: 'info', message: 'Security agent started', agent: 'security_agent' },
                { time: new Date(Date.now() - 30000), level: 'warn', message: 'Potential SQL injection vulnerability found', agent: 'security_agent' },
                { time: new Date(Date.now() - 60000), level: 'info', message: 'Testing agent completed successfully', agent: 'testing_agent' },
                { time: new Date(Date.now() - 90000), level: 'error', message: 'Documentation agent failed to parse OpenAPI spec', agent: 'docs_agent' },
                { time: new Date(Date.now() - 120000), level: 'info', message: 'Performance agent queued', agent: 'perf_agent' }
            ];

            updateAllDisplays();
        }

        // Update all display components
        function updateAllDisplays() {
            updateAgentStatusOverview();
            updateTaskQueue();
            updateSystemResources();
            updateActiveAgents();
            updateTimeline();
            updateLogs();
            updateTaskDistributionChart();
        }

        // Agent status overview
        function updateAgentStatusOverview() {
            const statusCounts = agents.reduce((acc, agent) => {
                acc[agent.status] = (acc[agent.status] || 0) + 1;
                return acc;
            }, {});

            const totalAgents = agents.length;
            const completedTasks = agents.filter(a => a.status === 'completed').length;
            const completionRate = totalAgents > 0 ? Math.round((completedTasks / totalAgents) * 100) : 0;

            document.getElementById('agentStatusOverview').innerHTML = `
                <div class="metric">
                    <span class="metric-label">Total Agents</span>
                    <span class="metric-value">${totalAgents}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Running</span>
                    <span class="metric-value">${statusCounts.running || 0}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Completed</span>
                    <span class="metric-value">${statusCounts.completed || 0}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Errors</span>
                    <span class="metric-value">${statusCounts.error || 0}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Pending</span>
                    <span class="metric-value">${statusCounts.pending || 0}</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${completionRate}%"></div>
                </div>
                <div class="progress-text">${completionRate}% Complete</div>
            `;
        }

        // Task queue display
        function updateTaskQueue() {
            const tasksByStatus = tasks.reduce((acc, task) => {
                if (!acc[task.status]) acc[task.status] = [];
                acc[task.status].push(task);
                return acc;
            }, {});

            let html = '';
            ['pending', 'in_progress', 'completed', 'blocked'].forEach(status => {
                const statusTasks = tasksByStatus[status] || [];
                if (statusTasks.length > 0) {
                    html += `<div class="metric">
                        <span class="metric-label">${status.replace('_', ' ').toUpperCase()}</span>
                        <span class="metric-value">${statusTasks.length}</span>
                    </div>`;
                }
            });

            document.getElementById('taskQueue').innerHTML = html || '<p>No tasks in queue</p>';
        }

        // System resources
        function updateSystemResources() {
            // Simulate resource data
            const cpuUsage = Math.floor(Math.random() * 40) + 20;
            const memoryUsage = Math.floor(Math.random() * 30) + 40;
            const diskUsage = Math.floor(Math.random() * 20) + 15;

            document.getElementById('systemResources').innerHTML = `
                <div class="metric">
                    <span class="metric-label">CPU Usage</span>
                    <span class="metric-value">${cpuUsage}%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Memory Usage</span>
                    <span class="metric-value">${memoryUsage}%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Disk Usage</span>
                    <span class="metric-value">${diskUsage}%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Active Processes</span>
                    <span class="metric-value">${agents.filter(a => a.status === 'running').length}</span>
                </div>
            `;

            // Update resource chart data
            resourceData.push({
                time: new Date(),
                cpu: cpuUsage,
                memory: memoryUsage,
                disk: diskUsage
            });

            // Keep only last 20 data points
            if (resourceData.length > 20) {
                resourceData.shift();
            }
        }

        // Active agents display
        function updateActiveAgents() {
            const container = document.getElementById('activeAgents');

            if (agents.length === 0) {
                container.innerHTML = '<p>No active agents</p>';
                return;
            }

            const agentCards = agents.map(agent => `
                <div class="card agent-card" onclick="showAgentDetails('${agent.id}')">
                    <div class="agent-header">
                        <div class="agent-id">${agent.id}</div>
                        <div class="agent-status status-${agent.status}">${agent.status}</div>
                    </div>
                    <div class="agent-task">${agent.task}</div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${agent.progress}%"></div>
                    </div>
                    <div class="progress-text">${agent.progress}% Complete</div>
                    ${agent.error ? `<div class="error-message">${agent.error}</div>` : ''}
                    <div class="metric">
                        <span class="metric-label">Priority</span>
                        <span class="metric-value">${agent.priority}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Type</span>
                        <span class="metric-value">${agent.type}</span>
                    </div>
                </div>
            `).join('');

            container.innerHTML = agentCards;
        }

        // Timeline display
        function updateTimeline() {
            const timelineEvents = agents
                .filter(agent => agent.startTime)
                .sort((a, b) => new Date(b.startTime) - new Date(a.startTime))
                .slice(0, 10);

            const timelineHtml = timelineEvents.map(agent => `
                <div class="timeline-item">
                    <div class="timeline-time">${formatTime(agent.startTime)}</div>
                    <div class="timeline-content">
                        <strong>${agent.id}</strong> ${agent.status === 'completed' ? 'completed' : 'started'}: ${agent.task}
                    </div>
                </div>
            `).join('');

            document.getElementById('timeline').innerHTML = timelineHtml || '<p>No recent activity</p>';
        }

        // Logs display
        function updateLogs() {
            const container = document.getElementById('logsContainer');

            const logsHtml = logs.slice(-50).reverse().map(log => `
                <div class="log-entry">
                    <span class="log-time">${formatTime(log.time)}</span>
                    <span class="log-level-${log.level}">[${log.level.toUpperCase()}]</span>
                    <span class="log-message">${log.message}</span>
                    ${log.agent ? `<span class="log-agent">(${log.agent})</span>` : ''}
                </div>
            `).join('');

            container.innerHTML = logsHtml || '<p>No logs available</p>';

            if (autoScrollLogs) {
                container.scrollTop = container.scrollHeight;
            }
        }

        // Chart initialization
        function initializeCharts() {
            // Resource chart
            const resourceCtx = document.getElementById('resourceChart').getContext('2d');
            charts.resource = new Chart(resourceCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'CPU %',
                            data: [],
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102,126,234,0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'Memory %',
                            data: [],
                            borderColor: '#764ba2',
                            backgroundColor: 'rgba(118,75,162,0.1)',
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top'
                        }
                    }
                }
            });

            // Task distribution chart
            const taskCtx = document.getElementById('taskDistributionChart').getContext('2d');
            charts.taskDistribution = new Chart(taskCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Security', 'Testing', 'Performance', 'Documentation', 'Refactoring'],
                    datasets: [{
                        data: [0, 0, 0, 0, 0],
                        backgroundColor: [
                            '#f44336',
                            '#4CAF50',
                            '#2196F3',
                            '#FFC107',
                            '#9c27b0'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        // Update charts
        function updateResourceChart() {
            if (resourceData.length === 0) return;

            const labels = resourceData.map(d => formatTime(d.time));
            const cpuData = resourceData.map(d => d.cpu);
            const memoryData = resourceData.map(d => d.memory);

            charts.resource.data.labels = labels;
            charts.resource.data.datasets[0].data = cpuData;
            charts.resource.data.datasets[1].data = memoryData;
            charts.resource.update('none');
        }

        function updateTaskDistributionChart() {
            const typeCounts = agents.reduce((acc, agent) => {
                acc[agent.type] = (acc[agent.type] || 0) + 1;
                return acc;
            }, {});

            const data = [
                typeCounts.security || 0,
                typeCounts.testing || 0,
                typeCounts.performance || 0,
                typeCounts.documentation || 0,
                typeCounts.refactoring || 0
            ];

            charts.taskDistribution.data.datasets[0].data = data;
            charts.taskDistribution.update();
        }

        // Activity heatmap
        function generateActivityHeatmap() {
            const container = document.getElementById('activityHeatmap');
            let html = '';

            for (let hour = 0; hour < 24; hour++) {
                const activity = Math.floor(Math.random() * 6); // 0-5 activity level
                const activityClass = activity > 0 ? `active-${activity}` : '';
                html += `<div class="heatmap-cell ${activityClass}" title="Hour ${hour}: ${activity} activities"></div>`;
            }

            container.innerHTML = html;
        }

        // Utility functions
        function formatTime(date) {
            if (!date) return 'N/A';
            if (typeof date === 'string') date = new Date(date);
            return date.toLocaleTimeString();
        }

        // Event handlers
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.body.className = currentTheme;
            localStorage.setItem('theme', currentTheme);
        }

        function refreshData() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify({ type: 'request_status' }));
            } else {
                loadDemoData();
            }
        }

        function exportLogs() {
            const logData = logs.map(log =>
                `${formatTime(log.time)} [${log.level.toUpperCase()}] ${log.message} ${log.agent ? `(${log.agent})` : ''}`
            ).join('\n');

            const blob = new Blob([logData], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `opencode-logs-${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showAgentDetails(agentId) {
            const agent = agents.find(a => a.id === agentId);
            if (!agent) return;

            const agentLogs = logs.filter(log => log.agent === agentId).slice(-20);
            const logHtml = agentLogs.map(log => `
                <div class="log-entry">
                    <span class="log-time">${formatTime(log.time)}</span>
                    <span class="log-level-${log.level}">[${log.level.toUpperCase()}]</span>
                    <span class="log-message">${log.message}</span>
                </div>
            `).join('');

            document.getElementById('modalTitle').textContent = `Agent Details: ${agentId}`;
            document.getElementById('modalBody').innerHTML = `
                <div class="metric">
                    <span class="metric-label">Status</span>
                    <span class="metric-value status-${agent.status}">${agent.status}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Type</span>
                    <span class="metric-value">${agent.type}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Priority</span>
                    <span class="metric-value">${agent.priority}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Progress</span>
                    <span class="metric-value">${agent.progress}%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Task</span>
                    <span class="metric-value">${agent.task}</span>
                </div>
                ${agent.error ? `<div class="error-message">${agent.error}</div>` : ''}
                <h3 style="margin: 20px 0 10px 0;">Recent Logs</h3>
                <div class="logs-container" style="max-height: 300px;">
                    ${logHtml || '<p>No logs available for this agent</p>'}
                </div>
            `;

            document.getElementById('detailModal').classList.add('active');
        }

        function showTaskDetails() {
            document.getElementById('modalTitle').textContent = 'Task Queue Details';

            const taskHtml = tasks.map(task => `
                <div class="card" style="margin-bottom: 16px;">
                    <div class="metric">
                        <span class="metric-label">ID</span>
                        <span class="metric-value">${task.id}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Type</span>
                        <span class="metric-value">${task.type}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Status</span>
                        <span class="metric-value status-${task.status}">${task.status}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Priority</span>
                        <span class="metric-value">${task.priority}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Description</span>
                        <span class="metric-value">${task.description}</span>
                    </div>
                </div>
            `).join('');

            document.getElementById('modalBody').innerHTML = taskHtml || '<p>No tasks available</p>';
            document.getElementById('detailModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('detailModal').classList.remove('active');
        }

        function filterAgents() {
            const statusFilter = document.getElementById('statusFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            const priorityFilter = document.getElementById('priorityFilter').value;
            const sortFilter = document.getElementById('sortFilter').value;
            const searchFilter = document.getElementById('searchFilter').value.toLowerCase();
            const dateFromFilter = document.getElementById('dateFromFilter').value;
            const dateToFilter = document.getElementById('dateToFilter').value;

            let filteredAgents = agents.filter(agent => {
                // Status filtering
                const matchesStatus = !statusFilter || agent.status === statusFilter;
                
                // Type filtering
                const matchesType = !typeFilter || agent.type === typeFilter;
                
                // Priority filtering
                const matchesPriority = !priorityFilter || agent.priority === priorityFilter;
                
                // Enhanced search with fuzzy matching
                const matchesSearch = !searchFilter || fuzzyMatch(searchFilter, [
                    agent.id,
                    agent.task,
                    agent.error || '',
                    agent.type,
                    agent.priority,
                    agent.status
                ]);
                
                // Date range filtering
                const matchesDateRange = checkDateRange(agent.startTime, dateFromFilter, dateToFilter);

                return matchesStatus && matchesType && matchesPriority && matchesSearch && matchesDateRange;
            });

            // Sorting
            filteredAgents = sortAgents(filteredAgents, sortFilter);

            // Update filter summary
            updateFilterSummary(filteredAgents.length, agents.length);

            // Update agents display with filtered results
            const container = document.getElementById('activeAgents');

            if (filteredAgents.length === 0) {
                container.innerHTML = '<div class="card"><p>No agents match the current filters</p></div>';
                return;
            }

            const agentCards = filteredAgents.map(agent => `
                <div class="card agent-card" onclick="showAgentDetails('${agent.id}')">
                    <div class="agent-header">
                        <div class="agent-id">${agent.id}</div>
                        <div class="agent-status status-${agent.status}">${agent.status}</div>
                    </div>
                    <div class="agent-task">${agent.task}</div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${agent.progress}%"></div>
                    </div>
                    <div class="progress-text">${agent.progress}% Complete</div>
                    ${agent.error ? `<div class="error-message">${agent.error}</div>` : ''}
                    <div class="metric">
                        <span class="metric-label">Priority</span>
                        <span class="metric-value">${agent.priority}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Type</span>
                        <span class="metric-value">${agent.type}</span>
                    </div>
                    ${agent.startTime ? `<div class="metric">
                        <span class="metric-label">Started</span>
                        <span class="metric-value">${formatTime(agent.startTime)}</span>
                    </div>` : ''}
                </div>
            `).join('');

            container.innerHTML = agentCards;
            
            // Save filter state
            saveFilterState();
        }

        // Enhanced search with fuzzy matching
        function fuzzyMatch(searchTerm, searchFields) {
            const lowerSearchTerm = searchTerm.toLowerCase();
            
            for (const field of searchFields) {
                const fieldValue = (field || '').toString().toLowerCase();
                
                // Exact match
                if (fieldValue.includes(lowerSearchTerm)) {
                    return true;
                }
                
                // Fuzzy matching with tolerance
                if (fuzzyMatchScore(lowerSearchTerm, fieldValue) > 0.6) {
                    return true;
                }
            }
            
            return false;
        }

        // Simple fuzzy matching algorithm
        function fuzzyMatchScore(search, target) {
            if (search === target) return 1.0;
            if (search.length === 0) return 1.0;
            if (target.length === 0) return 0.0;

            let score = 0;
            let searchIndex = 0;
            
            for (let i = 0; i < target.length && searchIndex < search.length; i++) {
                if (target[i] === search[searchIndex]) {
                    score++;
                    searchIndex++;
                }
            }
            
            return score / search.length;
        }

        // Date range checking
        function checkDateRange(agentDate, fromDate, toDate) {
            if (!fromDate && !toDate) return true;
            if (!agentDate) return !fromDate && !toDate;
            
            const agentDateObj = new Date(agentDate);
            const fromDateObj = fromDate ? new Date(fromDate) : null;
            const toDateObj = toDate ? new Date(toDate) : null;
            
            if (fromDateObj && agentDateObj < fromDateObj) return false;
            if (toDateObj && agentDateObj > new Date(toDateObj.getTime() + 86400000)) return false; // Add one day for inclusive range
            
            return true;
        }

        // Sorting functionality
        function sortAgents(agents, sortType) {
            const sortedAgents = [...agents];
            
            switch (sortType) {
                case 'oldest':
                    return sortedAgents.sort((a, b) => new Date(a.startTime || 0) - new Date(b.startTime || 0));
                case 'priority-high':
                    return sortedAgents.sort((a, b) => {
                        const priorityOrder = { high: 3, medium: 2, low: 1 };
                        return (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0);
                    });
                case 'priority-low':
                    return sortedAgents.sort((a, b) => {
                        const priorityOrder = { high: 3, medium: 2, low: 1 };
                        return (priorityOrder[a.priority] || 0) - (priorityOrder[b.priority] || 0);
                    });
                case 'status':
                    return sortedAgents.sort((a, b) => {
                        const statusOrder = { running: 4, pending: 3, error: 2, blocked: 1, completed: 0 };
                        return (statusOrder[b.status] || 0) - (statusOrder[a.status] || 0);
                    });
                case 'progress':
                    return sortedAgents.sort((a, b) => (b.progress || 0) - (a.progress || 0));
                case 'newest':
                default:
                    return sortedAgents.sort((a, b) => new Date(b.startTime || 0) - new Date(a.startTime || 0));
            }
        }

        // Update filter summary
        function updateFilterSummary(filteredCount, totalCount) {
            const summaryElement = document.getElementById('filterSummary');
            const filterCountElement = document.getElementById('filterCount');
            const totalCountElement = document.getElementById('totalCount');
            
            if (filterCountElement) filterCountElement.textContent = filteredCount;
            if (totalCountElement) totalCountElement.textContent = totalCount;
            
            // Highlight when filters are active
            if (summaryElement) {
                summaryElement.style.opacity = filteredCount < totalCount ? '1' : '0.8';
            }
        }

        // Clear all filters
        function clearAllFilters() {
            document.getElementById('statusFilter').value = '';
            document.getElementById('typeFilter').value = '';
            document.getElementById('priorityFilter').value = '';
            document.getElementById('sortFilter').value = 'newest';
            document.getElementById('searchFilter').value = '';
            document.getElementById('dateFromFilter').value = '';
            document.getElementById('dateToFilter').value = '';
            
            filterAgents();
        }

        // Export filtered agents
        function exportFilteredAgents() {
            const statusFilter = document.getElementById('statusFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            const priorityFilter = document.getElementById('priorityFilter').value;
            const searchFilter = document.getElementById('searchFilter').value;
            
            let filteredAgents = agents.filter(agent => {
                const matchesStatus = !statusFilter || agent.status === statusFilter;
                const matchesType = !typeFilter || agent.type === typeFilter;
                const matchesPriority = !priorityFilter || agent.priority === priorityFilter;
                const matchesSearch = !searchFilter || fuzzyMatch(searchFilter, [
                    agent.id, agent.task, agent.error || '', agent.type, agent.priority, agent.status
                ]);
                return matchesStatus && matchesType && matchesPriority && matchesSearch;
            });
            
            const csvData = [
                ['ID', 'Type', 'Status', 'Priority', 'Progress', 'Task', 'Start Time', 'Error'],
                ...filteredAgents.map(agent => [
                    agent.id,
                    agent.type,
                    agent.status,
                    agent.priority,
                    agent.progress + '%',
                    agent.task,
                    agent.startTime ? formatTime(agent.startTime) : '',
                    agent.error || ''
                ])
            ].map(row => row.join(',')).join('\n');
            
            const blob = new Blob([csvData], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `filtered-agents-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Save filter state to localStorage
        function saveFilterState() {
            if (typeof localStorage === 'undefined') return;
            
            const filterState = {
                status: document.getElementById('statusFilter').value,
                type: document.getElementById('typeFilter').value,
                priority: document.getElementById('priorityFilter').value,
                sort: document.getElementById('sortFilter').value,
                search: document.getElementById('searchFilter').value,
                dateFrom: document.getElementById('dateFromFilter').value,
                dateTo: document.getElementById('dateToFilter').value
            };
            
            localStorage.setItem('agentFilters', JSON.stringify(filterState));
        }

        // Load filter state from localStorage
        function loadFilterState() {
            if (typeof localStorage === 'undefined') return;
            
            const savedState = localStorage.getItem('agentFilters');
            if (!savedState) return;
            
            try {
                const filterState = JSON.parse(savedState);
                document.getElementById('statusFilter').value = filterState.status || '';
                document.getElementById('typeFilter').value = filterState.type || '';
                document.getElementById('priorityFilter').value = filterState.priority || '';
                document.getElementById('sortFilter').value = filterState.sort || 'newest';
                document.getElementById('searchFilter').value = filterState.search || '';
                document.getElementById('dateFromFilter').value = filterState.dateFrom || '';
                document.getElementById('dateToFilter').value = filterState.dateTo || '';
                
                // Apply the loaded filters
                setTimeout(() => filterAgents(), 100);
            } catch (error) {
                console.error('Error loading filter state:', error);
            }
        }

        function filterLogs() {
            const levelFilter = document.getElementById('logLevelFilter').value;
            const searchFilter = document.getElementById('logSearchFilter').value.toLowerCase();

            const filteredLogs = logs.filter(log => {
                const matchesLevel = !levelFilter || log.level === levelFilter;
                const matchesSearch = !searchFilter ||
                    log.message.toLowerCase().includes(searchFilter) ||
                    (log.agent && log.agent.toLowerCase().includes(searchFilter));

                return matchesLevel && matchesSearch;
            });

            const container = document.getElementById('logsContainer');
            const logsHtml = filteredLogs.slice(-50).reverse().map(log => `
                <div class="log-entry">
                    <span class="log-time">${formatTime(log.time)}</span>
                    <span class="log-level-${log.level}">[${log.level.toUpperCase()}]</span>
                    <span class="log-message">${log.message}</span>
                    ${log.agent ? `<span class="log-agent">(${log.agent})</span>` : ''}
                </div>
            `).join('');

            container.innerHTML = logsHtml || '<p>No logs match the current filters</p>';
        }

        function clearLogs() {
            logs = [];
            updateLogs();
        }

        function toggleLogAutoScroll() {
            autoScrollLogs = !autoScrollLogs;
            const button = event.target;
            button.textContent = `Auto-scroll: ${autoScrollLogs ? 'ON' : 'OFF'}`;
        }

        // Update functions called by WebSocket
        function updateAgent(agentData) {
            const existingIndex = agents.findIndex(a => a.id === agentData.id);
            if (existingIndex >= 0) {
                agents[existingIndex] = { ...agents[existingIndex], ...agentData };
            } else {
                agents.push(agentData);
            }
            updateActiveAgents();
            updateAgentStatusOverview();
        }

        function updateTask(taskData) {
            const existingIndex = tasks.findIndex(t => t.id === taskData.id);
            if (existingIndex >= 0) {
                tasks[existingIndex] = { ...tasks[existingIndex], ...taskData };
            } else {
                tasks.push(taskData);
            }
            updateTaskQueue();
        }

        function addLogEntry(logData) {
            logs.push(logData);
            if (logs.length > 1000) {
                logs.shift(); // Keep only last 1000 logs
            }
            updateLogs();
        }

        function updateResourceData(resourceData) {
            // Handle resource updates from WebSocket
            updateSystemResources();
        }

        // Load theme from localStorage
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            currentTheme = savedTheme;
            document.body.className = currentTheme;
        }

        // Clean up connections
        function cleanup() {
            if (websocket) {
                websocket.close(1000, 'Dashboard closing');
                websocket = null;
            }
            if (reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }
        }

        // Handle page unload
        window.addEventListener('beforeunload', cleanup);

        // Close modal when clicking outside
        document.getElementById('detailModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });
    </script>
</body>
</html>